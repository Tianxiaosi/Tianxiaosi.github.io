<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kian</title>
  
  <subtitle>I love three things in this world. Sun, moon and you. Sun for morning, moon for night , and you forever .</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tianxiaosi.github.io/"/>
  <updated>2018-06-28T00:50:48.984Z</updated>
  <id>https://tianxiaosi.github.io/</id>
  
  <author>
    <name>Kian_</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中设计模式</title>
    <link href="https://tianxiaosi.github.io/2018/06/28/JavaScript%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://tianxiaosi.github.io/2018/06/28/JavaScript中设计模式/</id>
    <published>2018-06-28T08:47:41.000Z</published>
    <updated>2018-06-28T00:50:48.984Z</updated>
    
    <content type="html"><![CDATA[<p> </p><h3>工厂模式</h3><p></p><blockquote><p>这种模式抽象了创建具体对象的过程，使用同一个接口可以创建很多对象，减少大量的重复代码。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age, job)&#123;</div><div class="line">var o = new Object();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = function()&#123;</div><div class="line">console.log(this.name);</div><div class="line">&#125;;</div><div class="line">return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = createPerson(&quot;Tom&quot;, 20, &quot;Software programmer&quot;);</div><div class="line">var person2 = createPerson(&quot;Jack&quot;, 18, &quot;Student&quot;);</div></pre></td></tr></table></figure><p></p><h3>构造函数模式</h3><p></p><blockquote><p> 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题，为了解决这个问题，soga 构造函数模式出现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">this.job = job;</div><div class="line">this.sayName = function()&#123;</div><div class="line">console.log(this.name);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Tom&quot;, 21, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Jack&quot;, 19, &quot;Student&quot;);</div></pre></td></tr></table></figure></p></blockquote><p>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历一下4个步骤：</p><ul><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（this指向这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象<br>最后这两个对象的构造函数属性（constructor）都指向Person，并且都是Person对象类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> console.log(person1.constructor == Person) //true</div><div class="line"> console.log(person2.constructor == Person) //true</div><div class="line"></div><div class="line">console.log(person1 instanceof Person) //true</div><div class="line">console.log(person2 instanceof Person) //true</div></pre></td></tr></table></figure></li></ul><p></p><h3>原型模式</h3><p></p><blockquote><p> 构造函数虽然好用，但是构造函数中的每个方法都要在每个实例上重新创建一遍。如上person1和person2都有一个sayName()的函数，因此每定义一个函数，就实例化了一个对象(在JavaScript中函数就是对象)。为了解决这个问题，所以又有了原型模式。 （写个代码考虑的问题真多，emmmmp….）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &quot;Kian&quot;;</div><div class="line">Person.prototype.age = 21;</div><div class="line">Person.prototype.job = &quot;developer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">console.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName(); //Kian</div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName(); //kian</div><div class="line">console.log(person1.sayName == person2.sayName) //true</div></pre></td></tr></table></figure><p>一说到原型就要讲关于原型链的内容，但是原型链我不会，好，讲的好，原型链讲解结束( mmp, 啥也没讲….)<br><img src="https://img-blog.csdn.net/20180622165400174?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5fMTIzNDU2Nzg5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="原型模式"><br>但是还是画一张图吧，手动草图，溜~</p><p></p><h3>组合使用构造函数模式和原型模式</h3><p></p><blockquote><p>该模式中，构造函数模式用来定义实例属性，而原型模式用来定义方法和共享的属性。这样每个实例搜会有自己的一份实例属性的副本，但同时有共享着对方法的引用，最大程度的节省了内存。（一群编程狂魔的自娱自乐….）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">this.job = job;</div><div class="line">this.friends = [&apos;Kian&apos;,&quot;Tone&quot;]</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">constructor: Person,</div><div class="line">sayName: function()&#123;</div><div class="line">console.log(this.name);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Tom&quot;, 22, &quot;Software Manager&quot;);</div><div class="line">var person2 = new Person(&quot;Jack&quot;, 20, &quot;Student&quot;)</div><div class="line"></div><div class="line">person1.firends.push(&quot;Mary&quot;);</div><div class="line"></div><div class="line">console.log(person1.friends); //&quot;Kian, Tone, Mary&quot;</div><div class="line">console.log(person2.fridens); //&quot;Kian, Tone&quot;</div><div class="line">console.log(person1.friends === person2.friends); //false</div><div class="line">console.log(person1.sayName === person2.sayName); //true</div></pre></td></tr></table></figure><p></p><h3>动态原型模式</h3><p></p><blockquote><p>该设计模式是为了解决没有其他OO语言经验的开发人员更好的理解独立的原型和和构造函数，该设计模式把所有信息都封装在构造函数中，而通过构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。 （mmp,没有经验还学，照顾的真到位…）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">this.job = job;</div><div class="line"></div><div class="line">if(typeof this.sayName != &quot;function&quot;)&#123;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">console.log(this.name);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Kian&quot;, 22, &quot;Software developer&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure></p></blockquote><p></p><h3>寄生构造函数模式</h3><p></p><blockquote><p>这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。 （这不是明明是工厂模式吗？黑人问号❓❓❓）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">var o = new Object();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = function()&#123;</div><div class="line">console.log(this.name);</div><div class="line">&#125;;</div><div class="line">return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person(&quot;Kian&quot;, 23, &quot;Software developer&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure></p></blockquote><p></p><h3>稳妥构造函数模式</h3><p></p><blockquote><p> 稳妥构造函数遵循与寄生构造函数类似的设计模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。（你们怕是有代码SB综合症吧….. 这和上面的有什么不同，心情复杂）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">var o = new Object();</div><div class="line">o.name = name;</div><div class="line">o.age = age;</div><div class="line">o.job = job;</div><div class="line">o.sayName = function()&#123;</div><div class="line">console.log(this.name);</div><div class="line">&#125;;</div><div class="line">return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = Person(&quot;Kian&quot;, 24, &quot;Software developer&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;/p&gt;&lt;h3&gt;工厂模式&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种模式抽象了创建具体对象的过程，使用同一个接口可以创建很多对象，减少大量的重复代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://tianxiaosi.github.io/tags/javascript/"/>
    
      <category term="Object" scheme="https://tianxiaosi.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数组的5种迭代方式</title>
    <link href="https://tianxiaosi.github.io/2018/06/22/JavaScript%E6%95%B0%E7%BB%84%E7%9A%845%E7%A7%8D%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F/"/>
    <id>https://tianxiaosi.github.io/2018/06/22/JavaScript数组的5种迭代方式/</id>
    <published>2018-06-22T10:26:38.000Z</published>
    <updated>2018-06-22T02:29:25.581Z</updated>
    
    <content type="html"><![CDATA[<p>ECMAScript 5 为数组定义了5个迭代方法。每个方法都接收<strong>两个参数</strong>： <strong>要在每一项上运行的函数和（可选的）运行该函数的作用域对象–影响this的值。</strong>  传入的这些方法中的函数会接收<strong>三个参数</strong>： <strong>数组项的值， 该项在数组中的位置和数组对象本身</strong>。 根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响访问的返回项。一下是这5个迭代方法的作用。</p><ul><li><blockquote><p> every() : 对数组中的每一项运行给定的函数，如果该函数对每一项都返回true，则返回true。</p></blockquote></li><li><blockquote><p> filter() : 对数组中的每一项运行给定的函数， 返回该函数会返回true的项组成的数组。</p></blockquote></li><li><blockquote><p> forEach() : 对数组中的每一项运行给定的函数。这个方法没有返回值。</p></blockquote></li><li><blockquote><p>map() : 对数组中的每一项运行给定的函数，  返回每次函数调用的结果组成的数组。</p></blockquote></li><li><blockquote><p>some() : 对数组中的每一项运行给定的函数，如果该函数对任一项返回true，则返回true。</p></blockquote></li></ul><hr><p>请看下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ES5： </div><div class="line">var numbers = [1,2,3,4,5,4,3,2,1]</div><div class="line">var everyReault = numbers.every(function(item, index, arr)&#123;</div><div class="line"> return item &gt; 2;</div><div class="line">&#125;)</div><div class="line">console.log(everyResult); //false</div><div class="line"></div><div class="line">var someResult = numbers.some(function(item, index, arr)&#123;</div><div class="line"> return item &gt;2;</div><div class="line">&#125;)</div><div class="line">console.log(someResult) //true</div><div class="line"></div><div class="line">ES6:</div><div class="line">   var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">   var everyResult = numbers.every((item, index, arr)=&gt;&#123;</div><div class="line">   return item &gt;2;</div><div class="line">   &#125;)</div><div class="line">   console.log(everyResult); </div><div class="line"> </div><div class="line">   var someResult = numbers.some((item, index, arr)=&gt;&#123;</div><div class="line">   return item &gt; 2;</div><div class="line">   &#125;)</div><div class="line">   console.log(someResult)</div></pre></td></tr></table></figure></p><p>以上代码调用了<code>every()</code>和<code>some()</code>，传入的函数只要给定项大于2就会返回<code>true</code>。对于<code>every()</code>，它返回的是<code>false</code>，因为只用部分数组项符合条件。对于<code>some()</code>，结果就是<code>true</code>，因为至少有一项是大于2的。</p><hr><p>下面来看<code>filter()</code>函数，它利用指定的函数确定是否在返回的数组中包含的某一项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ES5：</div><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var filterResult = numbers.filter(function(item. index, arr)&#123;</div><div class="line">return item &gt; 2;</div><div class="line">&#125;)</div><div class="line">console.log(filterResult); //[3,4,5,4,3]</div><div class="line"></div><div class="line">var mapResult = numbers.map(function(item, index, arr)&#123;</div><div class="line">return itme * 2;</div><div class="line">&#125;)</div><div class="line">console.log(mapResult); //[2,4,6,8,10,8,6,2]</div><div class="line"></div><div class="line">ES6：</div><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var filterResult = numbers.filter((item, index, arr)=&gt;&#123;</div><div class="line">return item &gt; 2;</div><div class="line">&#125;)</div><div class="line">console.log(filterResult)</div><div class="line"></div><div class="line">var mapResult = numbers.map((item, index, arr)=&gt;&#123;</div><div class="line">return item * 2;</div><div class="line">&#125;) </div><div class="line">console.log(mapResult);</div></pre></td></tr></table></figure></p><p>调用<code>filter()</code>方法创建并返回[3,4,5,4,3]，因为传入的函数对它们每一项都是<code>true</code>。<br>调用<code>map()</code>方法也返回一个数组，而这个数组的每一项都是在原始数组中对应项上运行传入函数的结果。</p><hr><p>最后一个方法是<code>forEach()</code>，它只对数组中的每一项运行传入的函数。这个方法没有返回值，本质上和for循环迭代数组一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ES5:</div><div class="line">var numbers = [1,2,3,4,5,4,3,2,1]</div><div class="line">numbers.forEach(function(item, index, arr)&#123;</div><div class="line">//this it options</div><div class="line">&#125;)</div><div class="line">ES6:</div><div class="line">var numbers = [1,2,3,4,5,4,3,2,1]</div><div class="line">numbers.forEach((item. index, arr)=&gt;&#123;</div><div class="line">//options</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ECMAScript 5 为数组定义了5个迭代方法。每个方法都接收&lt;strong&gt;两个参数&lt;/strong&gt;： &lt;strong&gt;要在每一项上运行的函数和（可选的）运行该函数的作用域对象–影响this的值。&lt;/strong&gt;  传入的这些方法中的函数会接收&lt;strong&gt;三个
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://tianxiaosi.github.io/tags/javascript/"/>
    
      <category term="数组" scheme="https://tianxiaosi.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>嘴角上扬的青春</title>
    <link href="https://tianxiaosi.github.io/2018/05/24/%E5%98%B4%E8%A7%92%E4%B8%8A%E6%89%AC%E7%9A%84%E9%9D%92%E6%98%A5/"/>
    <id>https://tianxiaosi.github.io/2018/05/24/嘴角上扬的青春/</id>
    <published>2018-05-23T16:57:52.000Z</published>
    <updated>2018-06-22T02:13:22.400Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=434070232&auto=1&height=66"></iframe><hr><p><strong>谁不曾想要自己的青春光彩照人？</strong> </p><p>谁不曾有着自己的梦想，曾几何时为了那些彻夜难眠，可什么时候，你把它们都丢了？</p><p>为什么最后，你想要的，变成了很多钱，有个像样的房子，买辆像样的车，度过还不错的人生？只是，如果梦想都一样，那还是梦想吗？</p><p>如果你的奋斗不是为了梦想，请停下来，想想自己现在所做的一切，是不是你真正想要的。最可怕的是，你要过四级你比谁都努力，你要考研你比谁起得都早，你要赶论文你比谁睡得都晚，可是在那之后，你再也不知道应该做什么了。</p><p>其实梦想触手可及，只是你渐渐地失去了勇气。你不敢变得不同，因为你怕跟这个世界格格不入，你怕一个人待着。你觉得孤独是可耻的，可是世界运转这么快，谁会在乎你是不是一个人？更何况，莫名的孤独感谁都有，即便你处于人群之中你也没法割断它，因为你的心是孤单的。</p><p>成人的世界，很复杂，说明书都像字典一样。不管你怎么做，总有人觉得不够好。你被狼狈地训斥了之后，相信你的，却是陌生人。而你最亲近的那个人，皱着眉头问你有没有这回事。<br>成长就是你哪怕难过得快死掉了，但你第二天还是照常去上课上班。</p><p>没有人知道你发生了什么，也没有人在意你发生了什么。你已经不再会为一两句夸奖就能开心一整天，你学会了把所有苦打断了牙往肚里咽，因为你知道倾诉根本不能解决问题。你等待的人迟迟不来，你选择单身，朋友都觉得你在恋爱这件事上不可理喻。</p><p>关于你的未来，只有你自己才知道。</p><p>既然解释不清，那就不要去解释。没有人在意你的青春，也别让别人左右了你的青春，对自己负责，不去别人的生活里随意指手画脚。活在自己的年纪里，看自己身边的风景。</p><p>把生命浪费在美好的事物上，不管那些在别人眼里看起来是否美好。趁年轻。愿你我老了之后回忆起来，有个嘴角上扬的青春。</p><hr><iframe height="498" width="510" src="https://player.youku.com/embed/XNjkzMDE5MTUy" frameborder="0" 'allowfullscreen'=""></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="随便抄的" scheme="https://tianxiaosi.github.io/tags/%E9%9A%8F%E4%BE%BF%E6%8A%84%E7%9A%84/"/>
    
  </entry>
  
  <entry>
    <title>CSS让元素居中显示</title>
    <link href="https://tianxiaosi.github.io/2018/05/12/CSS%E8%AE%A9%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA/"/>
    <id>https://tianxiaosi.github.io/2018/05/12/CSS让元素居中显示/</id>
    <published>2018-05-12T15:00:54.000Z</published>
    <updated>2018-05-12T07:02:18.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul><li><strong>水平居中：给div设置一个宽度，然后添加margin:0 auto属性</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">width:200px;</div><div class="line">margin:0 auto;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><ul><li><strong>让绝对定位的div居中</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">position: absolute;</div><div class="line">width: 300px;</div><div class="line">height: 300px;</div><div class="line">margin: auto;</div><div class="line">top: 0;</div><div class="line">left: 0;</div><div class="line">bottom: 0;</div><div class="line">right: 0;</div><div class="line">background-color: bule;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><ul><li><strong>确定容器的宽高 宽500 高 300 的层 设置元素的外边距</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">position: relative;/* 相对定位或绝对定位均可 */</div><div class="line">width:500px;</div><div class="line">height:300px;</div><div class="line">top: 50%;</div><div class="line">left: 50%;</div><div class="line">margin-top: -150px；</div><div class="line">margin-left:  -250px;     /* 外边距为自身宽高的一半 */</div><div class="line">//margin:-150px 0 0 -250px; /*一样*/</div><div class="line">background-color: blue;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><ul><li><strong>未知容器的宽高，利用 <code>transform</code> 属性</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">position: absolute;/* 相对定位或绝对定位均可 */</div><div class="line">width:500px;</div><div class="line">height:300px;</div><div class="line">top: 50%;</div><div class="line">left: 50%;</div><div class="line">transform: translate(-50%, -50%);</div><div class="line">background-color: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>利用 <code>flex</code> 布局</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">display: flex;</div><div class="line">align-items: center; /* 垂直居中 */</div><div class="line">justify-content: center;/* 水平居中 */</div><div class="line">&#125;</div><div class="line">.container div &#123;</div><div class="line">width: 100px;</div><div class="line">height: 100px;</div><div class="line">background-color: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;水平居中&quot;&gt;&lt;a href=&quot;#水平居中&quot; class=&quot;headerlink&quot; title=&quot;水平居中&quot;&gt;&lt;/a&gt;水平居中&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;水平居中：给div设置一个宽度，然后添加margin:0 auto属性&lt;/strong&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="CSS" scheme="https://tianxiaosi.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>十三个原因</title>
    <link href="https://tianxiaosi.github.io/2018/05/03/%E5%8D%81%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%9B%A0/"/>
    <id>https://tianxiaosi.github.io/2018/05/03/十三个原因/</id>
    <published>2018-05-03T13:52:57.000Z</published>
    <updated>2018-06-22T02:02:40.125Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe><p><img src="http://wx1.sinaimg.cn/large/006fVPCvly1fsjq64oopaj30u018f77f.jpg" alt="宣传海报"></p><blockquote><p><strong>剧情介绍:</strong> 该剧讲述一位名叫汉娜·贝克（Hannah Baker）的女高中生自杀了，剧中的旁白部分则来自于她自杀前录下的录音带。在这些录音带里，她点出了13位她认为应对自杀一事负责的人，他们要么没有对她施以援手，要么从某种程度伤害了她，而每一集中都会涉及名单上提到的一个人。当然，她也责怪自己，甚至有些过分责怪自己。<br>该剧根据2007年获得纽约时报最佳销售奖﹑Jay Asher所著的同名小说改篇，故事讲述一个少年Clay（Dylan Minnette 饰）在某夜收到一个鞋盒，内里装着自杀﹑已故的女同学Hannah（Katherine Langford 饰）的录音带。录音带中有指令，要把录音带从一个学生交到另一位手上，以向12位同学，用13个原因解释他们在她的死亡中，有着甚么身份，以及她为什么要自杀。</p></blockquote><hr><blockquote><p>有些人看起来很好很nice，所有人都喜欢但你永远不知道那个人什么时候会对你做什么</p></blockquote><hr><blockquote><p>Everything was better before</p></blockquote><hr><blockquote><p>每个人都可能有一些不为人知的伤痛，但这不能成为你伤害他人的理由。你不敢面对你自己不是你诋毁我的理由。</p></blockquote><p><a href="https://movie.douban.com/trailer/211074/#content" target="_blank" rel="external">宣传视频</a><br><a href="https://www.80s.tw/ju/20321" target="_blank" rel="external">下载链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="电影" scheme="https://tianxiaosi.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>BaiduIFE</title>
    <link href="https://tianxiaosi.github.io/2018/04/27/BaiduIFE/"/>
    <id>https://tianxiaosi.github.io/2018/04/27/BaiduIFE/</id>
    <published>2018-04-26T21:20:18.000Z</published>
    <updated>2018-04-30T04:09:50.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018百度前端技术学院学习"><a href="#2018百度前端技术学院学习" class="headerlink" title="2018百度前端技术学院学习"></a><center>2018百度前端技术学院学习</center></h2><ul><li><strong>CSS</strong><ul><li><a href="https://tianxiaosi.github.io/IFE/CSS/CSStaskOne.html">No.1 - 制作一个简单的菜单动画效果</a></li><li><a href="https://tianxiaosi.github.io/IFE/CSS/csstask2.html">No.2 - 初步接触 CSS 2D 变形</a></li><li><a href="https://tianxiaosi.github.io/IFE/CSS/csstask3.html">No.3 - CSS transition 和 CSS transform 配合制作动画</a></li><li><a href="https://tianxiaosi.github.io/IFE/CSS/csstask4.html">No.4 - 3D 空间的卡片翻转动效</a></li><li><a href="https://tianxiaosi.github.io/IFE/CSS/csstask5.html">No.5 - 纯 CSS 制作绕中轴旋转的立方体</a></li><li><a href="https://tianxiaosi.github.io/IFE/CSS/csstask6.html">No.6 - 利用 CSS animation 制作一个炫酷的 Slider</a></li><li><a href="https://tianxiaosi.github.io/IFE/CSS/csstask7.html">No.7 - 使用 animate.css 实现一个优雅的登录框</a></li></ul></li><li><strong>MVVM</strong><ul><li><a href="https://tianxiaosi.github.io/IFE/MVVM/taskONE.html">1.1 课程系列引导及准备工作</a> </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2018百度前端技术学院学习&quot;&gt;&lt;a href=&quot;#2018百度前端技术学院学习&quot; class=&quot;headerlink&quot; title=&quot;2018百度前端技术学院学习&quot;&gt;&lt;/a&gt;&lt;center&gt;2018百度前端技术学院学习&lt;/center&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="IFE" scheme="https://tianxiaosi.github.io/tags/IFE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://tianxiaosi.github.io/2018/04/26/hello-world/"/>
    <id>https://tianxiaosi.github.io/2018/04/26/hello-world/</id>
    <published>2018-04-26T06:01:15.708Z</published>
    <updated>2017-08-26T02:13:47.536Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="搭建博客" scheme="https://tianxiaosi.github.io/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://tianxiaosi.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://tianxiaosi.github.io/tags/github/"/>
    
      <category term="npm" scheme="https://tianxiaosi.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>FCC----------- Sum All Odd Fibonacci Numbers</title>
    <link href="https://tianxiaosi.github.io/2017/08/26/FCC-Sum-All-Odd-Fibonacci-Numbers/"/>
    <id>https://tianxiaosi.github.io/2017/08/26/FCC-Sum-All-Odd-Fibonacci-Numbers/</id>
    <published>2017-08-26T15:16:33.000Z</published>
    <updated>2017-08-26T07:31:52.620Z</updated>
    
    <content type="html"><![CDATA[<p><strong>给一个正整数num，返回小于或等于num的斐波纳契奇数之和。</strong></p><p><strong>斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。</strong></p><hr><ul><li>例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。<p></p></li></ul><blockquote><p>提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。</p></blockquote><hr><p>这是一些对你有帮助的资源:</p><p>关于运算符操作的文档</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_%28.25%29" target="_blank" rel="external">Remainder</a></p></blockquote><p>关于浏览器对于使用for循环内存占用过高崩溃解决方法</p><blockquote><p><a href="https://github.com/FreeCodeCampChina/freecodecamp.cn/issues/19" target="_blank" rel="external">Issue</a></p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function sumFibs(num) &#123;</div><div class="line">  var fibo = [1, 1],</div><div class="line">      temp = 0,</div><div class="line">      sum = 2;</div><div class="line">  while(true)&#123;</div><div class="line">    temp = fibo[0] + fibo[1];</div><div class="line">    if(temp &gt; num)&#123;</div><div class="line">      return sum;</div><div class="line">    &#125;</div><div class="line">    if(temp % 2 !== 0)&#123;</div><div class="line">      sum += temp;</div><div class="line">    &#125;</div><div class="line">    fibo[0] = fibo[1];</div><div class="line">    fibo[1] = temp;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">sumFibs(4);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;给一个正整数num，返回小于或等于num的斐波纳契奇数之和。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="FCC" scheme="https://tianxiaosi.github.io/categories/FCC/"/>
    
    
      <category term="javascript" scheme="https://tianxiaosi.github.io/tags/javascript/"/>
    
      <category term="fcc" scheme="https://tianxiaosi.github.io/tags/fcc/"/>
    
      <category term="数组" scheme="https://tianxiaosi.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
